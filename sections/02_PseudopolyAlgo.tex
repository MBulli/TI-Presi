% !TeX encoding = UTF-8
\section{Pseudopolynomielle Algorithmen}

\begin{frame}{Pseudopolynomielle Algorithmen}
Definition:

Sei $\Pi$ ein kombinatorisches Optimierungsproblem, so dass für alle Instanzen $I$ gilt, dass alle in $I$ vorkommenden Zahlen natürliche Zahlen sind. Sei maxnr($I$) die größte in $I$ vorkommende Zahl. Ein Algorithmus für $\Pi$ heißt pseudopolynomiell, falls es ein Polynom poly(.,.)  gibt, so 
dass für alle Instanzen $I$ seine Laufzeit poly(|$I$| ,maxnr($I$)) ist. 

\end{frame}
\begin{frame}{Pseudopolynomielle Algorithmen}
Bedeutung:

\begin{itemize}
\item
Die Laufzeit ist polynomiell in der Eingabelänge und der größten vorkommenden Zahl beschränkt

\item
Das Problem ist (unter der Annahme P $\neq$ PN) nur für Eingaben mit großen Zahlen schwer lösbar, sonst effizient

\end{itemize}

Verwendung:
\begin{itemize}
\item
Macht NP-Vollständige Probleme unter gewissen Einschränkungen effizient lösbar

\end{itemize}
\end{frame}

\begin{frame}{Pseudopolynomielle Algorithmen}
\textbf{Verständliches Beispiel:}
\textbf{Primzahltest}

\begin{itemize}
\item
Testet, ob eine gegebene Zahl eine Primzahl ist
\item
Klassisches Verfahren: Teile die Eingabe $n$ durch alle ganzen Zahlen $p < \sqrt{n}$
\end{itemize}

\begin{algorithm}[H]
\caption{Naiver Primzahltest}
    \begin{algorithmic}
        \Require{ Zahl $n$}
        \Ensure{$true$ falls $n$ durch $p$ teilbar, $false$ sonst.}
        \Function{IsPrim}{$n$}
            \For{Zahl $p$ mit $2 \leq p \leq \sqrt{n}$}
            \If{$n \mod{p} = 0$}
                  	\State return $true$
            \Else
                  	\State return $false$
            \EndIf
            \EndFor
        \EndFunction
    \end{algorithmic}
\end{algorithm}
\end{frame}

\begin{frame}{Pseudopolynomielle Algorithmen}
Problem:

\begin{itemize}
\item
Benötigt n-2 Divisionen, die laufzeit ist also linear in n
\item
Aber: Komplexität wird in der Eingabelänge |$n$| berechnet
\item
Daher: Exponentielle Laufzeit, problematisch bei großen Eingaben

\end{itemize}
\end{frame}

\begin{frame}{Pseudopolynomielle Algorithmen}
Beweis:

\end{frame}

\begin{frame}{Pseudopolynomielle Algorithmen}
Anwendung auf \textsc{Rucksack}
\newline

\begin{algorithm}[H]
    \caption{Exakter \rucksack/ Algorithmus}
        \begin{algorithmic}
            \State $\alpha:=0;$
            \Repeat
            \State $\alpha:=\alpha+1;$
            \For{$j:=1$ \textbf{to} $n$}
            \State $F_j(\alpha):=\min\{F_{j-1}(\alpha-p_j)+\text{vol}(j),F_{j-1}(\alpha)\};$
            \EndFor
            \Until{$B < F_n(\alpha)$}
            \State gib $\alpha-1$ aus$;$
        \end{algorithmic}
\end{algorithm}

\end{frame}

\begin{frame}{Pseudopolynomielle Algorithmen}
Bereits bekannt: Komplexität $\Rightarrow \mathcal{O}( n \cdot \OPT(I)) = \mathcal{O}( n^2 \cdot P_{\max})$ 
\begin{itemize}
\item
Aber: Worst-Case $: P_{max} = Opt(I) = \Theta(2^{|I|})$
\item
Daher: 
$\mathcal{O}(n\cdot 2^{|I|})$
\item
Die Laufzeit wird also exponentiell in der Eingabelänge
\item
Wenn die Eingabelänge polynomiell ist, dann läuft auch der Algorithmus polynomiell. Ist die Eingabelänge exponentiell groß, dann ist auch der Algorithmus exponentiell.
\item
\Rightarrow Pseudopolynomieller Algorithmus


\end{itemize}
\end{frame}
